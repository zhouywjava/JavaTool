package javaCore.bitCompute;

/**
 * @Description: 位运算测试 是针对二进制进行操作的。它们各自是&、|、^、~、>>、<<、>>>几个位操作符。不管是初始值是依照何种进制，都会换算成二进制进行位操作。
 * 对于原码。就是当前数字的二进制表现形式，如-1的原码是1000 0001。
 * 对于反码，正数的反码就是本身。负数的反码是二进制保留符号位。剩余位取反，比如-1的反码是1111 1110；
 * 对于补码，正数的反码、补码、原码都是一样的，负数的补码是在其反码的基础上+1，比如-1的补码是1111 1111。
 * 原码只是表现形式，用来转换为十进制。java中表示数是用补码
 * @Author: zyw
 * @Date: 2018/3/8
 */
public class BitComputeTest {

    public static void main(String[] args) {
        //注意java中int是32位的，因此一共有32位，一般只用高4位和低4位表示，其他省略。java使用补码来表示二进制数,最高位是符号位0正数，1负数
        int a = 12; // 1100
        int b = 5;  // 0101
        System.out.println(a & b); // 按位与运算 0100 4
        System.out.println(a | b); // 按位或运算 1101 13
        System.out.println(a ^ b); // 按位异或运算 1001 9
        System.out.println(~ b); // 取反 按位取反 0000 0101 -> 1111 1010  这个是负数的补码 是负数的原码取反后 +1 反着算就是负数的原码为 -1 取反 1111 1001 -> 保留最高位符号位取反 1000 0110 就是-6
        System.out.println(~ a); // 1111 0011 -> 1111 0010 -> 1000 1101 就是 -13
        System.out.println(a << 1); // a * 2  = 24 高位截断，低位补0
        System.out.println(a >> 2); // a / 4 = 3
        System.out.println(-1 >>> 1);// -1 的补码是 1111 1111 无符号右移 1 位 就是 高位补0,低位截断 0111 1111 为 Integer_max  2147483647
        System.out.println(-1 >> 1); //补码右移2位，高位补符号位，低位截断 所以还是 -1
    }
}
